import re
import xml.etree.ElementTree as ET


def return_english_letters(s):
    if bool(re.fullmatch(r"[A-Z_a-z0-9]+", s)):
        return s
    else:
        return ''


class BPMNToAirflowTransformer:
    def __init__(self, bpmn_file, bpmn_content):
        self.bpmn_file = bpmn_file
        self.bpmn_content = bpmn_content
        self.namespaces = {
            "bpmn": "http://www.omg.org/spec/BPMN/20100524/MODEL",
            "magic": "http://magic",
        }
        if self.bpmn_content is not None:
            self.root = ET.fromstring(bpmn_content)
        else:
            self.root = ET.parse(self.bpmn_file).getroot()

        self.tasks = {}
        self.sequence_flows = []
        self.process_id = None

        self.extract_process_id()
        self.extract_tasks()
        self.extract_sequence_flows()

    def extract_process_id(self):
        process = self.root.find("bpmn:process", self.namespaces)
        if process is not None:
            self.process_id = process.attrib.get("id").lower()

    def extract_tasks(self):
        """
        Extracts tasks from the BPMN file and maps them to Airflow task names.
        """
        for task_type in ["startEvent", "task", "serviceTask", "receiveTask", "endEvent"]:
            for task in self.root.findall(f".//bpmn:{task_type}", self.namespaces):
                task_id = task.attrib["id"]
                task_name = task.attrib.get("name", "").replace(" ", "_").lower() or task_id.lower()

                # Extract magic elements into a dictionary
                magic_data = {magic_elem.tag.split("}")[1]: magic_elem.text for magic_elem in
                              task.findall("magic:*", self.namespaces)}

                self.tasks[task_id] = {
                    "task_name": task_name,
                    "magic": magic_data
                }

    def is_all_english_letters(s):
        return bool(re.fullmatch(r"[A-Za-z]+", s))

    def extract_sequence_flows(self):
        """
        Extracts sequence flows from the BPMN file.
        """
        for sequence_flow in self.root.findall(".//bpmn:sequenceFlow", self.namespaces):
            source = sequence_flow.attrib["sourceRef"]
            target = sequence_flow.attrib["targetRef"]
            self.sequence_flows.append((source, target))

    def generate_airflow_dag(self):
        """
        Generates the Airflow DAG Python code.

        :return: Python code as a string.
        """
        dag_code = f"""from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime
from airflow.providers.common.sql.operators.sql import SQLExecuteQueryOperator


def sample_task(task_name):
    print(f"Executing: {{task_name}}")


default_args = {{
    'start_date': datetime(2023, 1, 1),
    'retries': 1,
}}

# This DAG automatically generated by XcodeFlow, Please DO NOT modify this code.
with DAG(dag_id='{self.process_id}', default_args=default_args, schedule_interval=None) as dag:
"""
        dag_code += f"    # tasks\n"

        # Add Airflow tasks
        airflow_tasks = {}
        i = 0
        for task_id, item in self.tasks.items():
            i = i + 1
            task_name = item["task_name"]
            dag_code += f"    \n"
            dag_code += f"    ################################################################### {i}\n"

            english_letters = return_english_letters(task_name)
            airflow_tasks[task_id] = f"t_{english_letters}_{task_id.lower().replace('activity_', '')}"
            task_id_var = f"t_{english_letters}_{task_id.lower().replace('activity_', '')}"

            if "sql" in item["magic"]:
                task_code = f"""    {task_id_var} = SQLExecuteQueryOperator(conn_id='postgres_default', task_id='{task_name}',sql=f\"""{item["magic"]["sql"]}\""")\n"""
                dag_code += task_code
            elif "script" in item["magic"]:
                dag_code += item["magic"]["script"]
            else:
                dag_code += f"    {task_id_var} = PythonOperator(task_id='{task_name}', python_callable=sample_task, op_args=['{task_name}'])\n"

        # Add sequence flows
        dag_code += f"    \n"
        dag_code += f"    # sequence_flows\n"

        for source, target in self.sequence_flows:
            if source in airflow_tasks and target in airflow_tasks:
                dag_code += f"    {airflow_tasks[source]} >> {airflow_tasks[target]}\n"

        return dag_code


if __name__ == '__main__':
    # Set the BPMN file path and output DAG file
    bpmn_file = "/Users/simon/workspaces/xcodeflow.git/bpmn/demo_process.bpmn"
    output_file = "/Users/simon/workspaces/xcodeflow.git/dags/demo_process.py"

    # Instantiate the transformer and transform the BPMN to DAG
    transformer = BPMNToAirflowTransformer(bpmn_file, None)
    dag_code_text = transformer.generate_airflow_dag()
    print(dag_code_text)
    with open(output_file, "w") as f:
        f.write(dag_code_text)

    print(f"DAG saved to {output_file}")
